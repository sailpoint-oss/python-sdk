# coding: utf-8

"""
    Identity Security Cloud V2024 API

    Use these APIs to interact with the Identity Security Cloud platform to achieve repeatable, automated processes with greater scalability. We encourage you to join the SailPoint Developer Community forum at https://developer.sailpoint.com/discuss to connect with other developers using our APIs.

    The version of the OpenAPI document: v2024
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json
import warnings

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from sailpoint.v2024.models.account_all_of_identity import AccountAllOfIdentity
from sailpoint.v2024.models.account_all_of_owner_identity import AccountAllOfOwnerIdentity
from sailpoint.v2024.models.account_all_of_recommendation import AccountAllOfRecommendation
from sailpoint.v2024.models.account_all_of_source_owner import AccountAllOfSourceOwner
from typing import Optional, Set
from typing_extensions import Self

class Account(BaseModel):
    """
    Account
    """ # noqa: E501
    id: Optional[StrictStr] = Field(default=None, description="System-generated unique ID of the Object")
    name: Optional[StrictStr] = Field(description="Name of the Object")
    created: Optional[datetime] = Field(default=None, description="Creation date of the Object")
    modified: Optional[datetime] = Field(default=None, description="Last modification date of the Object")
    source_id: StrictStr = Field(description="The unique ID of the source this account belongs to", alias="sourceId")
    source_name: Optional[StrictStr] = Field(description="The display name of the source this account belongs to", alias="sourceName")
    identity_id: Optional[StrictStr] = Field(default=None, description="The unique ID of the identity this account is correlated to", alias="identityId")
    cloud_lifecycle_state: Optional[StrictStr] = Field(default=None, description="The lifecycle state of the identity this account is correlated to", alias="cloudLifecycleState")
    identity_state: Optional[StrictStr] = Field(default=None, description="The identity state of the identity this account is correlated to", alias="identityState")
    connection_type: Optional[StrictStr] = Field(default=None, description="The connection type of the source this account is from", alias="connectionType")
    is_machine: Optional[StrictBool] = Field(default=False, description="Indicates if the account is of machine type", alias="isMachine")
    recommendation: Optional[AccountAllOfRecommendation] = None
    attributes: Optional[Dict[str, Any]] = Field(description="The account attributes that are aggregated")
    authoritative: StrictBool = Field(description="Indicates if this account is from an authoritative source")
    description: Optional[StrictStr] = Field(default=None, description="A description of the account")
    disabled: StrictBool = Field(description="Indicates if the account is currently disabled")
    locked: StrictBool = Field(description="Indicates if the account is currently locked")
    native_identity: StrictStr = Field(description="The unique ID of the account generated by the source system", alias="nativeIdentity")
    system_account: StrictBool = Field(description="If true, this is a user account within IdentityNow.  If false, this is an account from a source system.", alias="systemAccount")
    uncorrelated: StrictBool = Field(description="Indicates if this account is not correlated to an identity")
    uuid: Optional[StrictStr] = Field(default=None, description="The unique ID of the account as determined by the account schema")
    manually_correlated: StrictBool = Field(description="Indicates if the account has been manually correlated to an identity", alias="manuallyCorrelated")
    has_entitlements: StrictBool = Field(description="Indicates if the account has entitlements", alias="hasEntitlements")
    identity: Optional[AccountAllOfIdentity] = None
    source_owner: Optional[AccountAllOfSourceOwner] = Field(default=None, alias="sourceOwner")
    features: Optional[StrictStr] = Field(default=None, description="A string list containing the owning source's features")
    origin: Optional[StrictStr] = Field(default=None, description="The origin of the account either aggregated or provisioned")
    owner_identity: Optional[AccountAllOfOwnerIdentity] = Field(default=None, alias="ownerIdentity")
    __properties: ClassVar[List[str]] = ["id", "name", "created", "modified", "sourceId", "sourceName", "identityId", "cloudLifecycleState", "identityState", "connectionType", "isMachine", "recommendation", "attributes", "authoritative", "description", "disabled", "locked", "nativeIdentity", "systemAccount", "uncorrelated", "uuid", "manuallyCorrelated", "hasEntitlements", "identity", "sourceOwner", "features", "origin", "ownerIdentity"]

    @field_validator('origin')
    def origin_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['AGGREGATED', 'PROVISIONED']):
            warnings.warn(f"must be one of enum values ('AGGREGATED', 'PROVISIONED') unknown value: {value}")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Account from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "id",
            "created",
            "modified",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of recommendation
        if self.recommendation:
            _dict['recommendation'] = self.recommendation.to_dict()
        # override the default output from pydantic by calling `to_dict()` of identity
        if self.identity:
            _dict['identity'] = self.identity.to_dict()
        # override the default output from pydantic by calling `to_dict()` of source_owner
        if self.source_owner:
            _dict['sourceOwner'] = self.source_owner.to_dict()
        # override the default output from pydantic by calling `to_dict()` of owner_identity
        if self.owner_identity:
            _dict['ownerIdentity'] = self.owner_identity.to_dict()
        # set to None if name (nullable) is None
        # and model_fields_set contains the field
        if self.name is None and "name" in self.model_fields_set:
            _dict['name'] = None

        # set to None if source_name (nullable) is None
        # and model_fields_set contains the field
        if self.source_name is None and "source_name" in self.model_fields_set:
            _dict['sourceName'] = None

        # set to None if cloud_lifecycle_state (nullable) is None
        # and model_fields_set contains the field
        if self.cloud_lifecycle_state is None and "cloud_lifecycle_state" in self.model_fields_set:
            _dict['cloudLifecycleState'] = None

        # set to None if identity_state (nullable) is None
        # and model_fields_set contains the field
        if self.identity_state is None and "identity_state" in self.model_fields_set:
            _dict['identityState'] = None

        # set to None if connection_type (nullable) is None
        # and model_fields_set contains the field
        if self.connection_type is None and "connection_type" in self.model_fields_set:
            _dict['connectionType'] = None

        # set to None if attributes (nullable) is None
        # and model_fields_set contains the field
        if self.attributes is None and "attributes" in self.model_fields_set:
            _dict['attributes'] = None

        # set to None if description (nullable) is None
        # and model_fields_set contains the field
        if self.description is None and "description" in self.model_fields_set:
            _dict['description'] = None

        # set to None if uuid (nullable) is None
        # and model_fields_set contains the field
        if self.uuid is None and "uuid" in self.model_fields_set:
            _dict['uuid'] = None

        # set to None if source_owner (nullable) is None
        # and model_fields_set contains the field
        if self.source_owner is None and "source_owner" in self.model_fields_set:
            _dict['sourceOwner'] = None

        # set to None if features (nullable) is None
        # and model_fields_set contains the field
        if self.features is None and "features" in self.model_fields_set:
            _dict['features'] = None

        # set to None if origin (nullable) is None
        # and model_fields_set contains the field
        if self.origin is None and "origin" in self.model_fields_set:
            _dict['origin'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Account from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "id": obj.get("id"),
            "name": obj.get("name"),
            "created": obj.get("created"),
            "modified": obj.get("modified"),
            "sourceId": obj.get("sourceId"),
            "sourceName": obj.get("sourceName"),
            "identityId": obj.get("identityId"),
            "cloudLifecycleState": obj.get("cloudLifecycleState"),
            "identityState": obj.get("identityState"),
            "connectionType": obj.get("connectionType"),
            "isMachine": obj.get("isMachine") if obj.get("isMachine") is not None else False,
            "recommendation": AccountAllOfRecommendation.from_dict(obj["recommendation"]) if obj.get("recommendation") is not None else None,
            "attributes": obj.get("attributes"),
            "authoritative": obj.get("authoritative"),
            "description": obj.get("description"),
            "disabled": obj.get("disabled"),
            "locked": obj.get("locked"),
            "nativeIdentity": obj.get("nativeIdentity"),
            "systemAccount": obj.get("systemAccount"),
            "uncorrelated": obj.get("uncorrelated"),
            "uuid": obj.get("uuid"),
            "manuallyCorrelated": obj.get("manuallyCorrelated"),
            "hasEntitlements": obj.get("hasEntitlements"),
            "identity": AccountAllOfIdentity.from_dict(obj["identity"]) if obj.get("identity") is not None else None,
            "sourceOwner": AccountAllOfSourceOwner.from_dict(obj["sourceOwner"]) if obj.get("sourceOwner") is not None else None,
            "features": obj.get("features"),
            "origin": obj.get("origin"),
            "ownerIdentity": AccountAllOfOwnerIdentity.from_dict(obj["ownerIdentity"]) if obj.get("ownerIdentity") is not None else None
        })
        return _obj


