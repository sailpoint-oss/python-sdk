# coding: utf-8

"""
    Identity Security Cloud V3 API

    Use these APIs to interact with the Identity Security Cloud platform to achieve repeatable, automated processes with greater scalability. We encourage you to join the SailPoint Developer Community forum at https://developer.sailpoint.com/discuss to connect with other developers using our APIs.

    The version of the OpenAPI document: 3.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from sailpoint.v3.models.account_all_of_owner_group import AccountAllOfOwnerGroup
from sailpoint.v3.models.account_all_of_owner_identity import AccountAllOfOwnerIdentity
from sailpoint.v3.models.account_all_of_source_owner import AccountAllOfSourceOwner
from sailpoint.v3.models.base_reference_dto import BaseReferenceDto
from typing import Optional, Set
from typing_extensions import Self

class Account(BaseModel):
    """
    Account
    """ # noqa: E501
    id: Optional[StrictStr] = Field(default=None, description="System-generated unique ID of the Object")
    name: StrictStr = Field(description="Name of the Object")
    created: Optional[datetime] = Field(default=None, description="Creation date of the Object")
    modified: Optional[datetime] = Field(default=None, description="Last modification date of the Object")
    source_id: StrictStr = Field(description="The unique ID of the source this account belongs to", alias="sourceId")
    source_name: StrictStr = Field(description="The display name of the source this account belongs to", alias="sourceName")
    identity_id: Optional[StrictStr] = Field(default=None, description="The unique ID of the identity this account is correlated to", alias="identityId")
    cloud_lifecycle_state: Optional[StrictStr] = Field(default=None, description="The lifecycle state of the identity this account is correlated to", alias="cloudLifecycleState")
    identity_state: Optional[StrictStr] = Field(default=None, description="The identity state of the identity this account is correlated to", alias="identityState")
    connection_type: Optional[StrictStr] = Field(default=None, description="The connection type of the source this account is from", alias="connectionType")
    type: Optional[StrictStr] = Field(default=None, description="The type of the account")
    attributes: Optional[Dict[str, Any]] = Field(description="The account attributes that are aggregated")
    authoritative: StrictBool = Field(description="Indicates if this account is from an authoritative source")
    description: Optional[StrictStr] = Field(default=None, description="A description of the account")
    disabled: StrictBool = Field(description="Indicates if the account is currently disabled")
    locked: StrictBool = Field(description="Indicates if the account is currently locked")
    native_identity: StrictStr = Field(description="The unique ID of the account generated by the source system", alias="nativeIdentity")
    system_account: StrictBool = Field(description="If true, this is a user account within IdentityNow.  If false, this is an account from a source system.", alias="systemAccount")
    uncorrelated: StrictBool = Field(description="Indicates if this account is not correlated to an identity")
    uuid: Optional[StrictStr] = Field(default=None, description="The unique ID of the account as determined by the account schema")
    manually_correlated: StrictBool = Field(description="Indicates if the account has been manually correlated to an identity", alias="manuallyCorrelated")
    has_entitlements: StrictBool = Field(description="Indicates if the account has entitlements", alias="hasEntitlements")
    identity: Optional[BaseReferenceDto] = None
    source_owner: Optional[AccountAllOfSourceOwner] = Field(default=None, alias="sourceOwner")
    features: Optional[StrictStr] = Field(default=None, description="A string list containing the owning source's features")
    origin: Optional[StrictStr] = Field(default=None, description="The origin of the account either aggregated or provisioned")
    owner_identity: Optional[AccountAllOfOwnerIdentity] = Field(default=None, alias="ownerIdentity")
    owner_group: Optional[AccountAllOfOwnerGroup] = Field(default=None, alias="ownerGroup")
    __properties: ClassVar[List[str]] = ["id", "name", "created", "modified", "sourceId", "sourceName", "identityId", "cloudLifecycleState", "identityState", "connectionType", "type", "attributes", "authoritative", "description", "disabled", "locked", "nativeIdentity", "systemAccount", "uncorrelated", "uuid", "manuallyCorrelated", "hasEntitlements", "identity", "sourceOwner", "features", "origin", "ownerIdentity", "ownerGroup"]

    @field_validator('origin')
    def origin_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['AGGREGATED', 'PROVISIONED', 'null']):
            raise ValueError("must be one of enum values ('AGGREGATED', 'PROVISIONED', 'null')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Account from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "id",
            "created",
            "modified",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of identity
        if self.identity:
            _dict['identity'] = self.identity.to_dict()
        # override the default output from pydantic by calling `to_dict()` of source_owner
        if self.source_owner:
            _dict['sourceOwner'] = self.source_owner.to_dict()
        # override the default output from pydantic by calling `to_dict()` of owner_identity
        if self.owner_identity:
            _dict['ownerIdentity'] = self.owner_identity.to_dict()
        # override the default output from pydantic by calling `to_dict()` of owner_group
        if self.owner_group:
            _dict['ownerGroup'] = self.owner_group.to_dict()
        # set to None if cloud_lifecycle_state (nullable) is None
        # and model_fields_set contains the field
        if self.cloud_lifecycle_state is None and "cloud_lifecycle_state" in self.model_fields_set:
            _dict['cloudLifecycleState'] = None

        # set to None if identity_state (nullable) is None
        # and model_fields_set contains the field
        if self.identity_state is None and "identity_state" in self.model_fields_set:
            _dict['identityState'] = None

        # set to None if connection_type (nullable) is None
        # and model_fields_set contains the field
        if self.connection_type is None and "connection_type" in self.model_fields_set:
            _dict['connectionType'] = None

        # set to None if type (nullable) is None
        # and model_fields_set contains the field
        if self.type is None and "type" in self.model_fields_set:
            _dict['type'] = None

        # set to None if attributes (nullable) is None
        # and model_fields_set contains the field
        if self.attributes is None and "attributes" in self.model_fields_set:
            _dict['attributes'] = None

        # set to None if description (nullable) is None
        # and model_fields_set contains the field
        if self.description is None and "description" in self.model_fields_set:
            _dict['description'] = None

        # set to None if uuid (nullable) is None
        # and model_fields_set contains the field
        if self.uuid is None and "uuid" in self.model_fields_set:
            _dict['uuid'] = None

        # set to None if source_owner (nullable) is None
        # and model_fields_set contains the field
        if self.source_owner is None and "source_owner" in self.model_fields_set:
            _dict['sourceOwner'] = None

        # set to None if features (nullable) is None
        # and model_fields_set contains the field
        if self.features is None and "features" in self.model_fields_set:
            _dict['features'] = None

        # set to None if origin (nullable) is None
        # and model_fields_set contains the field
        if self.origin is None and "origin" in self.model_fields_set:
            _dict['origin'] = None

        # set to None if owner_identity (nullable) is None
        # and model_fields_set contains the field
        if self.owner_identity is None and "owner_identity" in self.model_fields_set:
            _dict['ownerIdentity'] = None

        # set to None if owner_group (nullable) is None
        # and model_fields_set contains the field
        if self.owner_group is None and "owner_group" in self.model_fields_set:
            _dict['ownerGroup'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Account from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "id": obj.get("id"),
            "name": obj.get("name"),
            "created": obj.get("created"),
            "modified": obj.get("modified"),
            "sourceId": obj.get("sourceId"),
            "sourceName": obj.get("sourceName"),
            "identityId": obj.get("identityId"),
            "cloudLifecycleState": obj.get("cloudLifecycleState"),
            "identityState": obj.get("identityState"),
            "connectionType": obj.get("connectionType"),
            "type": obj.get("type"),
            "attributes": obj.get("attributes"),
            "authoritative": obj.get("authoritative"),
            "description": obj.get("description"),
            "disabled": obj.get("disabled"),
            "locked": obj.get("locked"),
            "nativeIdentity": obj.get("nativeIdentity"),
            "systemAccount": obj.get("systemAccount"),
            "uncorrelated": obj.get("uncorrelated"),
            "uuid": obj.get("uuid"),
            "manuallyCorrelated": obj.get("manuallyCorrelated"),
            "hasEntitlements": obj.get("hasEntitlements"),
            "identity": BaseReferenceDto.from_dict(obj["identity"]) if obj.get("identity") is not None else None,
            "sourceOwner": AccountAllOfSourceOwner.from_dict(obj["sourceOwner"]) if obj.get("sourceOwner") is not None else None,
            "features": obj.get("features"),
            "origin": obj.get("origin"),
            "ownerIdentity": AccountAllOfOwnerIdentity.from_dict(obj["ownerIdentity"]) if obj.get("ownerIdentity") is not None else None,
            "ownerGroup": AccountAllOfOwnerGroup.from_dict(obj["ownerGroup"]) if obj.get("ownerGroup") is not None else None
        })
        return _obj


